#!/usr/bin/env ruby
# encoding: utf-8

#     SeqTrimBB: Next generation sequencing preprocessor
#     Copyright (C) <2017>
#     Authors: Diego Dario Guerrero Fernandez, Rafael
#              Nuñez Serrano

#              email: soporte@scbi.uma.es - http://www.scbi.uma.es
#
#     This program is free software: you can redistribute it and/or modify
#     it under the terms of the GNU Affero General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
#
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU Affero General Public License for more details.
#
#     You should have received a copy of the GNU Affero General Public License
#     along with this program.  If not, see <http://www.gnu.org/licenses/>.

#= SeqtrimBB
#
#== Running
#
# SeqtrimBB can be run locally or in a parallel/distributted environment.
#
#=== Running locally
#* list
#
#=== Running in a distributted environment
#
#== SEC 2
#
#=== SUB 2.1
#


# $: << File.expand_path('~/progs/ruby/gems/seqtrimbb/lib/')

require 'seqtrimbb'
require 'scbi_headers'


def put_header
  
  header = ScbiHeader.new('SeqTrimBB',Seqtrimbb::SEQTRIM_VERSION)

  header.description="SeqtrimBB is a customizable pre-processing software for NGS (Next Generation Sequencing) biological data based on BBtools suite. It is specially suited for Illumina datasets (normal and paired-end), although it could be easyly adapted to any other situation."

  header.copyright='SeqtrimBB 2017. BBTools Copyright (c) 2014, The Regents of the University of California, through Lawrence Berkeley National Laboratory (subject to receipt of any required approvals from the U.S. Dept. of Energy).  All rights reserved.'

  header.authors<< "Rafael Núñez"
  header.authors<< "Darío Guerrero"

  # header.articles<< "Article one: with one description line"
  # header.articles<< "Article two: with one description line"

  # To output the header
  puts header

end

put_header

############ PATHS #######################

OUTPUT_PATH = File.expand_path('output_files_tmp')
OUTPLUGINSTATS = File.expand_path('output_files_tmp/plugin_stats')

# if there is a BBDB environment var, then use it
if ENV['BBDB']
  $DB_PATH = ENV['BBDB']
else # otherwise use SEQTRIM_PATH + DB
  $DB_PATH = File.expand_path(File.join(SEQTRIM_PATH, "DB"))
end

# PATH TO BBTOOLS
# if there is a BBTOOLS_PATH environment var, then use it
if ENV['BBTOOLS_PATH']
   $BBPATH = ENV['BBTOOLS_PATH']
else # otherwise use the result of which bbmap.sh
   $BBPATH = File.expand_path(File.dirname(%x[which bbmap.sh]))
end

#Checks install requeriments
require 'install_requirements'
ins = InstallRequirements.new
if (!ins.check_install_requirements)
  exit(-1)
end

require 'logger'
require 'optparse'
require 'seqtrim.rb'
require 'params.rb'
require 'plugin.rb'
require 'plugin_manager.rb'
require 'list_db.rb'
require 'install_database.rb'
require 'check_database.rb'
require 'check_external_database.rb'
require 'getsetram.rb' 

def show_additional_help

  puts "\n"*3
  puts "E.g.: processing a fastq file"
  puts "#{File.basename($0)} -t genomics_basic.txt -Q sequences.fastq"
  puts "\n"*2

  puts "E.g.: processing a fasta file with qual"
  puts "#{File.basename($0)} -t genomics_basic.txt -Q sequences.fasta -q sequences_quality.qual"

  templates = Dir.glob(File.join(ROOT_PATH,'templates','*.txt')).map{|t| File.basename(t)}

  puts "\n\n  ========================================================================================================"
  puts "  Available templates to use with -t option (you can also use your own template):"
  puts "  Templates at: #{File.join(ROOT_PATH,'templates')}"
  puts "  ========================================================================================================\n\n"

  templates.map{|e| puts "      "+e}

  puts "\n\n  ========================================================================================================"
  puts "  Available databases to use in custom template files (you can also use your own database)"
  puts "  ========================================================================================================\n\n"

  ListDb.new($DB_PATH,'all')

  exit

end

# Reads the parameters from console. For this is used ARGV, that is an array.

options = {}

optparse = OptionParser.new do |opts|

  # Set a banner, displayed at the top
  # of the help screen.
  opts.banner = "Usage: #{$0} -t template_file \{-Q seq_file\} [options]"

  options[:workers] = 1
  opts.on( '-w', '--workers COUNT', 'Number of threads' ) do |workers|
      begin
        options[:workers] = Integer(workers)
      rescue
        STDERR.puts "ERROR:Invalid threads parameter #{options[:workers]}"
        exit -1
      end
  end

  options[:max_ram] = nil
  opts.on( '-m', '--max_RAM MEMORY', 'Max RAM to use, for example, 1g means 1 gig' ) do |max_ram|
    options[:max_ram] = max_ram.downcase
  end

  options[:check_db] = true
  opts.on( '-c', '--check_databases', 'Skip Checking databases step' ) do
    options[:check_db] = false
  end

  #options[:install_db] = nil
  #opts.on( '-i', '--install_databases TYPE', 'Install base databases') do |db_type|
  #  options[:install_db] = db_type
  #end

  options[:logfile] = STDOUT
  opts.on( '-l', '--logfile FILE', 'Write log to FILE' ) do |file|
    options[:logfile] = file
  end

  options[:file] = nil
  opts.on( '-Q', '-- FILE FILE1,FILE2',Array, 'Input fastq/fasta file' ) do |file|
    options[:file] = file
  end

  options[:qual] = nil
  opts.on( '-q', '--qual FILE1,FILE2',Array, 'Qual input file' ) do |file|
    options[:qual] = file
  end

  options[:list_db] = nil
  options[:list_db_name] = 'all'
  opts.on( '-L', '--list_db [DB_NAME]', 'List entries IDs in DB_NAME. Use "-L all" to view all available databases' ) do |value|
    options[:list_db] = true
    options[:list_db_name] = value if value
  end

  options[:gen_params] = false
  opts.on( '-G', '--generate_template', 'Generates a sample template file with default parameters' ) do
    options[:gen_params] = true
  end

  options[:template] = nil
  opts.on( '-t', '--template TEMPLATE_FILE', 'Use TEMPLATE_FILE instead of default parameters' ) do |file|
    options[:template] = file
  end

  options[:overwrite_params] = nil
  opts.on( '-P', '--overwrite_params "PARAM1;PARAM2"','Params and their values to overwrite default and templates parameters' ) do |oparams|
    options[:overwrite_params] = oparams
  end

  options[:ext_cmd] = nil
  opts.on( '-E', '--external_cmd External call to insert in the pipe', 'Add one call (or more already piped between them) to an assembler or mapping tool' ) do |cmd|
    options[:ext_cmd] = cmd
  end

  options[:skip_report] = false
  opts.on( '-R', '--no-report', 'Do not generate final PDF report (gem scbi_seqtrimbb_report required if you want to generate PDF report).' ) do
    options[:skip_report] = true
  end

  options[:write_in_gzip] = true
  opts.on( '-z', '--gzip', 'Avoid generating output files in gzip format.' ) do
    options[:write_in_gzip] = false
  end

  options[:force_execution] = false
  opts.on( '-F', '--force', 'Force SeqtrimBB execution deleting previous output files' ) do
    options[:force_execution] = true
  end

  options[:final_output_path] = 'output_files'
  opts.on( '-O', '--ouput output_files', 'Output folder. It should not exists. output_files by default') do |folder|
    options[:final_output_path] = folder
  end

# This displays the help screen, all programs are assumed to have this option.
  opts.on_tail('-h', '--help', 'Display this screen') do
    puts opts
    show_additional_help
    exit -1
  end
end

# parse options and remove from ARGV
optparse.parse!

# Set Final output path
DEFAULT_FINAL_OUTPUT_PATH = options[:final_output_path]

if options[:list_db]
  # List database entries in a database
  ListDb.new($DB_PATH,options[:list_db_name])
  exit -1
end

if options[:gen_params]
  # Generates a sample params file in current directory
  Params.generate_sample_params
  exit -1
end

if options[:max_ram].nil?
# Setting RAM usage
  free_memory = GetSetRAM.new
  options[:max_ram] = free_memory.value
end

#set logger
#system('rm logs/*')

FileUtils.mkdir('logs') if !File.exists?('logs')

$LOG = Logger.new(options[:logfile])
$LOG.datetime_format = "%Y-%m-%d %H:%M:%S"
#logger.level = Logger::INFO

#DEBUG < INFO < WARN < ERROR < FATAL < UNKNOWN

$LOG.info("SeqTrimBB version #{Seqtrimbb::SEQTRIM_VERSION}")
$LOG.info("Command: #{$0}")
$LOG.info("SeqtrimBB path: #{ROOT_PATH}")
$LOG.info("BBTools path: #{$BBPATH}")

$LOG.info("Using options: \n"+ JSON::pretty_generate(options))

# Install/Check databases on DB_PATH

#if options[:install_db]
  #install databases
 # InstallDatabase.new(options[:install_db],$DB_PATH)
  # check databases indices
  #CheckDatabase.new($DB_PATH,options[:workers],options[:max_ram])
  #exit
#end

if options[:check_db]
  # checks databases indices
  CheckDatabase.new($DB_PATH,options[:workers],options[:max_ram])
end

# checks for essential arguments

required_options = options[:file] && options[:template]

if (ARGV.count != 0) || (!required_options) 
  puts "You must provide all required options"
  puts ""
  puts optparse.help
  exit(-1)
end

# checks for a previous execution
if Dir.exists?(DEFAULT_FINAL_OUTPUT_PATH) || Dir.exists?(OUTPUT_PATH)
  if options[:force_execution]
   #Warning
   $LOG.error "Temporal output folder #{OUTPUT_PATH} already exists and --force parameter is active.\n Removing output_files_tmp from the current directory." if Dir.exists?(OUTPUT_PATH)
   $LOG.error "Output folder #{options[:final_output_path]} already exists and --force parameter is active.\n Removing #{options[:final_output_path]}" if Dir.exists?(DEFAULT_FINAL_OUTPUT_PATH)
   #Remove old folders
   FileUtils.rm_rf(OUTPUT_PATH) if File.exists?(OUTPUT_PATH)
   FileUtils.rm_rf(DEFAULT_FINAL_OUTPUT_PATH) if File.exists?(DEFAULT_FINAL_OUTPUT_PATH)
  else
   #Error
   $LOG.error "Output folder #{options[:final_output_path]}, or temporal output folder #{OUTPUT_PATH} already exists.\n Remove them if you want to launch SeqtrimBB again or add --force_execution parameter to the command line."
   exit(-1)
  end
end

# check for templates existence
if !File.exists?(options[:template])
  if File.exists?(File.join(ROOT_PATH,'templates',options[:template]))
    options[:template] = File.join(ROOT_PATH,'templates',options[:template])
  else
    $LOG.error "Params file: #{options[:template]} doesn't exists. \n\nYou can use your own template or specify one from this list:\n============================="
    puts Dir.glob(File.join(ROOT_PATH,'templates','*.txt')).map{|t| File.basename(t)}
    exit(-1)
  end
end
$LOG.info "Using params file: #{options[:template]}"

# check for files existence
if options[:file]
  # Test file
  options[:file].each do |seq_file|
   if (!seq_file.nil? && seq_file!='-' && !File.exists?(File.expand_path(seq_file)))
    $LOG.error "Input file: #{seq_file} doesn't exists"
    exit(-1)
   end
  end 
end

# check for qual files existence
if options[:qual]
  options[:qual].each do |qual_file|
    # qual file
    if (!qual_file.nil? && qual_file!='-' && !File.exists?(File.expand_path(qual_file)))
      $LOG.error "Input file: #{qual_file} doesn't exists"
      exit(-1)
    end
  end
end

s = Seqtrim.new(options)

#generate report

#if !options[:skip_report] && system("which generate_report.rb > /dev/null ")
#  cmd="generate_report.rb #{OUTPUT_PATH} 2> report_generation_errors.log"
 # $LOG.info "Generating report #{cmd}"
  # `#{cmd}`
#else
 # skip_text=','
  #if options[:skip_report]
   # skip_text=' and remove the -R option from the command line.'
  #end

  #$LOG.info "If you want a detailed report in PDF format, be sure you have installed the optional seqtrimbb_report gem (gem install seqtrimbb_report)#{skip_text}"
  #$LOG.info "Closing"
#end

if (Seqtrim.exit_status>=0) 
  FileUtils.mv OUTPUT_PATH, DEFAULT_FINAL_OUTPUT_PATH
end

exit(Seqtrim.exit_status)

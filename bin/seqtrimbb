#!/usr/bin/env ruby
# encoding: utf-8

#     SeqTrimBB: Next generation sequencing preprocessor
#     Copyright (C) <2017>
#     Authors: Rafael Nu√±ez Serrano, Diego Dario Guerrero 
#              Fernandez

#     email: soporte@scbi.uma.es - http://www.scbi.uma.es

###############################################################################
# FINDS
###############################################################################

ROOT_PATH = File.dirname(__FILE__)
SEQTRIM_PATH = File.join(ROOT_PATH,'..')

# Finds classes in 'lib' folder
$: << File.expand_path(File.join(SEQTRIM_PATH,'lib'))
# Finds classes in 'seqtrimbb' folder
$: << File.expand_path(File.join(SEQTRIM_PATH,'lib','seqtrimbb'))
# Finds classes in 'classes' folder
$: << File.expand_path(File.join(SEQTRIM_PATH,'lib','seqtrimbb','classes'))
# Finds classes in 'plugins' folder
$: << File.expand_path(File.join(SEQTRIM_PATH,'lib','seqtrimbb','plugins'))

###############################################################################
# METHODS
###############################################################################

# Decamelize strings
class String  
   def decamelize 
           self.to_s. 
                   gsub(/([A-Z\d]+)([A-Z][a-z])/, '\1_\2'). 
                   gsub(/([a-z]+)([A-Z\d])/, '\1_\2'). 
                   gsub(/([A-Z]{2,})(\d+)/i, '\1_\2'). 
                   gsub(/(\d+)([a-z])/i, '\1_\2'). 
                   gsub(/(.+?)\&(.+?)/, '\1_&_\2'). 
                   gsub(/\s/, '_').downcase 
   end
end

# Slice hashes (extract a subhash)
class Hash
   def slice(*keys)
           ::Hash[[keys, self.values_at(*keys)].transpose]
   end
end

#Check external requirements. Takes a external call, and test if it can execute
def check_external_requirements(req,req_call,version=nil,source_url)
     #Checks if external requirement is present
       begin
               cmd = IO.popen(req_call)
       rescue
               STDERR.puts "Unable to find external requirement: #{req}\nYou can download it from #{source_url}"
               exit (-1)
       end
     #Checks version
       if !version.nil?
             #Extract version 
               version_from_cmd = cmd.read.split("\n")[0].gsub(/\D/,'').to_i
               if version_from_cmd < version.to_i
                       STDERR.puts "Detected an old #{req} version. An updated is required."
                       exit(-1)
               end
       end
       cmd.close

end

#Check for previous execution (looks for outputs folder/s existence)
def check_previous_execution(output_folders,force_execution)

   # test each folder existence
       folders.each do |folder|
               if Dir.exist?(folder)
                       msg = "Output folder #{folder} already exists. "
                       if force_execution
                             msg << "Force execution parameter is set to true. Removing #{folder}"
                             STDERR.puts "WARNING. " + msg
                             FileUtils.rm_rf(folder)
                       else
                             msg << "To retry, remove it or add --force_execution parameter to the command line."
                             STDERR.puts "ERROR. " + msg
                             exit(-1)
                       end
               end
       end

end

def show_additional_help

     #Fastq preprocessing
       STDERR.puts "\n\n\nE.g.: processing a fastq file"
       STDERR.puts "#{File.basename($0)} -t template.txt -Q sequences.fastq\n\n"
     #Available templates
       STDERR.puts "\n\n  ========================================================================================================"
       STDERR.puts "  Available templates to use with -t option (you can also use your own template):"
       STDERR.puts "  Templates at: #{File.join(SEQTRIM_PATH,'templates')}"
       STDERR.puts "  ========================================================================================================\n\n"
       Dir.glob(File.join(SEQTRIM_PATH,'templates','*.txt')).map{|t| puts "      #{File.basename(t)}"}
     #Exiting
       exit

end

###############################################################################
# REQUIRE ESSENTIALS
###############################################################################

require 'seqtrimbb'
require 'logger'
require 'fileutils'
require 'optparse'
require 'json'
require 'params'
require 'database_support'
require 'plugin'
require 'plugin_manager'
require 'bbtools'

###############################################################################
# WORKING PATHS AND HEADER
###############################################################################

#temp output path
OUTPUT_PATH = File.expand_path('output_files_tmp')
#If there is a BBDB environment var (databases location), then use it
if ENV['BBDB']
       db_path = ENV['BBDB']
else # otherwise use SEQTRIM_PATH + DB
       db_path = File.expand_path(File.join(SEQTRIM_PATH, "DB"))
end
#First checks if BBtools is installed, then set a BBtools path. If there is a BBTOOLS_PATH environment var, then use it
check_external_requirements('BBtools','bbversion.sh',37.53,"http://sourceforge.net/projects/bbmap/")
if ENV['BBTOOLS_PATH']
       bb_path = ENV['BBTOOLS_PATH']
else # otherwise use the result of which bbmap.sh
       bb_path  = File.expand_path(File.dirname(%x[which bbmap.sh]))
end
#Puts header
STDERR.puts "SeqTrimBB version #{Seqtrimbb::SEQTRIM_VERSION}"
STDERR.puts " - Command: #{$0}"
STDERR.puts " - SeqtrimBB path: #{SEQTRIM_PATH}"
STDERR.puts " - BBtools version #{bb_version}"
STDERR.puts " - BBTools path: #{bb_path}"

###############################################################################
# OPTIONS PARSING
###############################################################################

# Reads the parameters from console. For this is used ARGV, that is an array.
options = {}

optparse = OptionParser.new do |opts|

  # Set a banner, displayed at the top
  # of the help screen.
  opts.banner = "Usage: #{$0} -t template_file \{-Q seq_file\} [options]"

  options[:workers] = 1
  opts.on( '-w', '--workers COUNT', 'Number of threads' ) do |workers|
         begin
                 options[:workers] = Integer(workers)
         rescue
                 STDERR.puts "ERROR:Invalid threads parameter #{options[:workers]}"
                 exit (-1)
         end
  end

  options[:install_db] = false
  options[:install_db_name] = Array.new
  opts.on( '-i', '--install_databases [DB_NAME]',Array,'If no DB_NAME is specified, install (or reinstall) all default databases provided with SeqTrimBB. Default databases can be modified with --default_databases options.')
         options[:install_db] = true
         options[:install_db_name] = value if !value.nil?
  end

  options[:check_db] = true
  opts.on( '-c', '--check_databases [RETRY]', 'Skip Checking databases step' ) do
         options[:check_db] = false
  end

  options[:list_db] = false
  options[:list_db_name] = Array.new
  opts.on( '-L', '--list_db [DB_NAME]',Array,'List entries in DB_NAME. Use "-L" to view all available databases' ) do |value|
         options[:list_db] = true
         options[:list_db_name] = value if !value.nil?
  end

  options[:databases_action]='replace'
  opts.on('-da','--databases_action [ACTION]',%w["replace","add","remove"],'Action to be applied to SeqtrimBB databases configuration: replace (replace SeqtrimBBs default databases list for one provided with -dl option), add (-dl list to default list) or remove (-dl list to default list). This option permanently modifies SeqTrimBBs configuration if user have write permissions. Default value is replace.') do |action|
         options[:databases_action] = action
  end

  options[:databases_list] = Array.new
  opts.on( '-dl', '--databases_list DATABASE DATABASE1,DATABASEN',Array,'List of databases to replace/add/remove. To restore default list provided at installation time, execute SeqTrimBB with "-dl default".') do |database|
         options[:databases_list] = [database].flatten
  end

  options[:file] = Array.new
  opts.on( '-Q', '-- FILE FILE1,FILE2',Array, 'Input fastq/fasta file' ) do |file|
         if !file.empty? && file.map { |f| File.exist?(File.expand_path(f)) }.all?
                 options[:file] = file
         else
                 STDERR.puts "ERROR. File: #{file.select{ |f| File.exist?(f) }.join(" ")} does not exists"
                 exit(-1)
         end
  end

  options[:qual] = Array.new
  opts.on( '-q', '--qual FILE1,FILE2',Array, 'Qual input file' ) do |file|
         if !file.empty? && file.map { |f| File.exist?(File.expand_path(f)) }.all?
                 options[:qual] = file
         else
                 STDERR.puts "ERROR. File: #{file.select{ |f| File.exist?(f) }.join(" ")} does not exists"
                 exit(-1)
         end
  end

  options[:template] = nil
  opts.on( '-t', '--template TEMPLATE_FILE', 'Use TEMPLATE_FILE instead of default parameters' ) do |file|
         if !file.nil? && (File.exist?(File.expand_path(file)) || File.exist?(File.join(SEQTRIM_PATH,'templates',file)))
                 options[:template] = File.exists?(File.expand_path(file)) ? File.expand_path(file) : File.join(SEQTRIM_PATH,'templates',file)
         else
                 STDERR.puts "Params file: #{file} doesn't exists. \n\nYou can use your own template or specify one from this list:\n=============================\n"
                 STDERR.puts "#{Dir.glob(File.join(SEQTRIM_PATH,'templates','*.txt')).map{|t| File.basename(t)}.join("\n")}"
                 exit(-1)
         end
  end

  options[:overwrite_params] = nil
  opts.on( '-P', '--overwrite_params "PARAM1;PARAM2"','Params and their values to overwrite default and templates parameters' ) do |oparams|
         options[:overwrite_params] = oparams
  end

  options[:ext_cmd] = nil
  opts.on( '-E', '--external_cmd External call to insert in the pipe', 'Add one call (or more already piped between them) to an assembler or mapping tool' ) do |cmd|
         options[:ext_cmd] = cmd
  end

  #options[:skip_report] = false
  #opts.on( '-R', '--no-report', 'Do not generate final PDF report (gem scbi_seqtrimbb_report required if you want to generate PDF report).' ) do
  #  options[:skip_report] = true
  #end

  options[:write_in_gzip] = true
  opts.on( '-z', '--no_gzip', 'Avoid generating output files in gzip format.' ) do
         options[:write_in_gzip] = false
  end

  options[:force_execution] = false
  opts.on( '-F', '--force', 'Force SeqtrimBB execution deleting previous output files' ) do
         options[:force_execution] = true
  end

  options[:generate_stats] = false
  opts.on('-G','--generate_stats [OPTION]','Generate initial and/or final FastQC reports. Use -G to generate both reports, -G initial to generate just the initial report and -G final for the final report.')
  #TERMINAR
  end

  options[:final_output_path] = 'output_files'
  opts.on( '-O', '--ouput output_files', 'Output folder. It should not exists. output_files by default') do |folder|
         options[:final_output_path] = folder
  end

# This displays the help screen, all programs are assumed to have this option.
  opts.on_tail('-h', '--help', 'Display this screen') do
         STDERR.puts opts
         show_additional_help
         exit(-1)
  end
end
# parse options and remove from ARGV
optparse.parse!

STDERR.puts " - Using options: \n"+ JSON::pretty_generate(options))

###############################################################################
# Initialize BBtools
###############################################################################

bbtools = BBtools.new(bb_path)

###############################################################################
# GENERAL CHECK POINTS AND OPTIONAL WORKS
###############################################################################

## Works related to internal databases

# First initialize DatabasesSupport class. If options[:install databases] also install databases
stbb_databases = DatabasesSupport.new(options.slice(:workers,:databases_action,:databases_list),db_path,bbtools)
# OPT: list databases
if options[:list_db]
     # List database entries in a database
       stbb_databases.list_databases(options[:list_db_name])
       exit(-1)
end
# DATABASES MAINTENANCE (If its needed or requested. Build databases structure, install databases, check and update index)
stbb_databases.maintenance(options.slice(:install_db,:install_db_name,:check_db))

# SAVING DATABASES INFO JSON
#stbb_databases.save_json if stbb_databases.save_info
## Other optional works

## Checks for required options
if (ARGV.count != 0) || ([:file,:template].map { |opt| options[opt].empty? }.any?) 
       STDERR.puts "To preprocess a sample you must provide all required options.\n"
       puts optparse.help
       exit(-1)
end
## Checks for a previous execution!
check_previous_execution([OUTPUT_PATH,options[:final_output_path]],options[:force_execution])

###############################################################################
# READ AND PROCESS PARAMS
###############################################################################

# Reads parameters from template
#$LOG.info "Reading params"
#$LOG.info "Using params file: #{options[:template]}"
# Read and process
#params = Params.new(options)
#params.process_params(bbtools,db_path)

# Store default options from params in bbtools
#bbtools.store_default(param.get_param('default_options'))

# Finally checks plugin_list param. If it fails, exit.
#pl_error = []
#comment='Plugins applied to every sequence, separated by commas. Order is important'
#params.check_param(pl_error,'plugin_list','PluginList',nil,comment)
#if !pl_error.empty?
 #  $LOG.error pl_error
  # exit(-1)
#end

###############################################################################
# INITIAL STATS
###############################################################################
#external_requirements['FastQC']= ['fastqc',"\nYou can download it from http://www.bioinformatics.babraham.ac.uk/projects/fastqc/"]

# Extract initial global stats
#if params.exist?('generate_initial_stats') && params.get_param('generate_initial_stats').to_s=='true'
  # $LOG.info "Calculating initial stats: i.e. FastQC"
# fastqc cmd 
  # cmd="fastqc -q -o #{OUTPUT_PATH} -t #{$GLOBAL_PARAMS['cores']} #{params.get_param('inputfiles').join(" ")}"
  # system(cmd)
#else
  # $LOG.info "Skipping calculating initial stats phase."
#end

###############################################################################
# MAIN WORK
###############################################################################

# Exit status
#exit_status = 0

# load plugin_list
#plugin_list = params.get_param('plugin_list')
#$LOG.info "Loading plugins [#{plugin_list}]"

# Make working directory and subdirectories
#[OUTPUT_PATH,File.join(OUTPUT_PATH,'plugins_stats')].map{|d| Dir.mkdir(d)}

# Initialize plugins manager
#plugin_manager = PluginManager.new(plugin_list,params,bbtools)

# load and check plugins params
#$LOG.info "Loading and checking plugins params"
#if !plugin_manager.check_plugins_params(params)
   # $LOG.error "Plugin check failed"
    # save used params to file
    #params.save_file(File.join(OUTPUT_PATH,'used_params.txt'))
    #exit(-1)
#end


#generate report

#if !options[:skip_report] && system("which generate_report.rb > /dev/null ")
#  cmd="generate_report.rb #{OUTPUT_PATH} 2> report_generation_errors.log"
 # $LOG.info "Generating report #{cmd}"
  # `#{cmd}`
#else
 # skip_text=','
  #if options[:skip_report]
   # skip_text=' and remove the -R option from the command line.'
  #end

  #$LOG.info "If you want a detailed report in PDF format, be sure you have installed the optional seqtrimbb_report gem (gem install seqtrimbb_report)#{skip_text}"
  #$LOG.info "Closing"
#end

#if (exit_status>=0) 
 # FileUtils.mv OUTPUT_PATH, options[:final_output_path]
#end
# Exiting
#exit(exit_status)
exit

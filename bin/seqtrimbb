#!/usr/bin/env ruby
# encoding: utf-8

#     SeqTrimBB: Next generation sequencing preprocessor
#     Copyright (C) <2017>
#     Authors: Diego Dario Guerrero Fernandez, Rafael
#              Nuñez Serrano

#              email: soporte@scbi.uma.es - http://www.scbi.uma.es
#
#     This program is free software: you can redistribute it and/or modify
#     it under the terms of the GNU Affero General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
#
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU Affero General Public License for more details.
#
#     You should have received a copy of the GNU Affero General Public License
#     along with this program.  If not, see <http://www.gnu.org/licenses/>.

#= SeqtrimBB
#
#== Running
#
# SeqtrimBB can be run locally or in a parallel/distributted environment.
#
#=== Running locally
#* list
#
#=== Running in a distributted environment
#
#== SEC 2
#
#=== SUB 2.1
#


# $: << File.expand_path('~/progs/ruby/gems/seqtrimbb/lib/')

require 'seqtrimbb'
require 'scbi_headers'


def put_header
  
  header = ScbiHeader.new('SeqTrimBB',Seqtrimbb::SEQTRIM_VERSION)

  header.description="SeqtrimBB is a customizable pre-processing software for NGS (Next Generation Sequencing) biological data based on BBtools suite. It is specially suited for Illumina datasets (normal and paired-end), although it could be easyly adapted to any other situation."

  header.copyright='SeqtrimBB 2017. BBTools Copyright (c) 2014, The Regents of the University of California, through Lawrence Berkeley National Laboratory (subject to receipt of any required approvals from the U.S. Dept. of Energy).  All rights reserved.'

  header.authors<< "Rafael Núñez"
  header.authors<< "Darío Guerrero"

  # header.articles<< "Article one: with one description line"
  # header.articles<< "Article two: with one description line"

  # To output the header
  puts header

end

put_header

############ PATHS #######################

OUTPUT_PATH = 'output_files_tmp'
OUTPLUGINSTATS = 'output_files_tmp/plugin_stats'
DEFAULT_FINAL_OUTPUT_PATH = 'output_files'

# if there is a BLASTDB environment var, then use it
if ENV['DB']# && Dir.exists?(ENV['BLASTDB'])
  $DB_PATH = ENV['DB']
else # otherwise use SEQTRIM_PATH + DB
  $DB_PATH = File.expand_path(File.join(SEQTRIM_PATH, "DB"))
end

# TODO - COMENTAR todas las clases y metodos para que salga la descripcion cuando hagas rdoc en el terminal

#Checks install requeriments

require 'install_requirements'

ins = InstallRequirements.new

if (!ins.check_install_requirements)
  exit(-1)
end

require "logger"
require 'optparse'
require "seqtrim"
require "params.rb"
require "plugin.rb"
require "plugin_manager.rb"
require 'list_db'
require 'install_database'
require 'check_database' 

def show_additional_help

  puts "\n"*3
  puts "E.g.: processing a fastq sequences file"
  puts "#{File.basename($0)} -t genomics_basic.txt -Q sequences.fastq"
  puts "\n"*2

  puts "E.g.: processing a fasta file with qual"
  puts "#{File.basename($0)} -t genomics_basic.txt -Q sequences.fasta -q sequences_quality.qual"

  templates = Dir.glob(File.join(ROOT_PATH,'templates','*.txt')).map{|t| File.basename(t)}

  puts "\n\n  ========================================================================================================"
  puts "  Available templates to use with -t option (you can also use your own template):"
  puts "  Templates at: #{File.join(ROOT_PATH,'templates')}"
  puts "  ========================================================================================================\n\n"

  templates.map{|e| puts "      "+e}

  puts "\n\n  ========================================================================================================"
  puts "  Available databases to use in custom template files (you can also use your own database):"
  puts "  Databases at: #{$DB_PATH}"
  puts "  ========================================================================================================\n\n"

  ListDb.list_databases($DB_PATH)

  exit

end


# Reads the parameters from console. For this is used ARGV, that is an array.

options = {}

optparse = OptionParser.new do |opts|

  # Set a banner, displayed at the top
  # of the help screen.
  opts.banner = "Usage: #{$0} -t template_file \{-Q seq_file\} [options]"

  options[:workers] = 1

  opts.on( '-w', '--workers COUNT', 'Number of threads' ) do |workers|
      begin
        options[:workers] = Integer(workers)
      rescue
        STDERR.puts "ERROR:Invalid threads parameter #{options[:workers]}"
        exit -1
      end
  end

  options[:max_ram] = nil
  opts.on( '-m', '--max_RAM MEMORY', 'Max RAM to use, for example, 1G means 1 gig' ) do |max_ram|
    options[:max_ram] = max_ram.upcase
  end

  options[:check_db] = true
  opts.on( '-c', '--check_databases', 'Check databases' ) do
    options[:check_db] = false
  end

  options[:install_db] = nil
  opts.on( '-i', '--install_databases TYPE', 'Install base databases') do |db_type|
    options[:install_db] = db_type
  end

  options[:logfile] = STDOUT
  opts.on( '-l', '--logfile FILE', 'Write log to FILE' ) do |file|
    options[:logfile] = file
  end

  options[:file] = nil
  opts.on( '-Q', '-- FILE FILE1,FILE2',Array, 'Input fastq/fasta file' ) do |file|
    options[:file] = file
  end

  options[:qual] = nil
  opts.on( '-q', '--qual FILE1,FILE2',Array, 'Qual input file' ) do |file|
    options[:qual] = file
  end

  options[:list_db] = nil
  options[:list_db_name] = 'ALL'

  opts.on( '-L', '--list_db [DB_NAME]', 'List entries IDs in DB_NAME. Use "-L all" to view all available databases' ) do |value|
    options[:list_db] = true
    options[:list_db_name] = value if value
  end

  options[:gen_params] = false
  opts.on( '-G', '--generate_template', 'Generates a sample template file with default parameters' ) do
    options[:gen_params] = true
  end

  options[:template] = nil
  opts.on( '-t', '--template TEMPLATE_FILE', 'Use TEMPLATE_FILE instead of default parameters' ) do |file|
    options[:template] = file
  end

  options[:overwrite_params] = nil
  opts.on( '-P', '--overwrite_params "PARAM1;PARAM2"','Params and their values to overwrite default and templates parameters' ) do |oparams|
    options[:overwrite_params] = oparams
  end

  options[:ext_cmd] = nil
  opts.on( '-E', '--external_cmd External call to insert in the pipe', 'Add one call (or more already piped between them) to an assembler or mapping tool' ) do |cmd|
    options[:ext_cmd] = cmd
  end

  options[:skip_report] = false
  opts.on( '-R', '--no-report', 'Do not generate final PDF report (gem scbi_seqtrimbb_report required if you want to generate PDF report).' ) do
    options[:skip_report] = true
  end

  options[:write_in_gzip] = true
  opts.on( '-z', '--gzip', 'Avoid generating output files in gzip format.' ) do
    options[:write_in_gzip] = false
  end

  options[:final_output_path] = DEFAULT_FINAL_OUTPUT_PATH
  opts.on( '-O', '--ouput output_files', 'Output folder. It should not exists. output_files by default') do |folder|
    options[:final_output_path] = folder
  end

# This displays the help screen, all programs are
# assumed to have this option.

  opts.on_tail( '-h', '--help', 'Display this screen' ) do
    puts opts
    show_additional_help
    exit -1
  end
end

# parse options and remove from ARGV

optparse.parse!

if options[:list_db]
  # List database entries in a database
  ListDb.new($DB_PATH,options[:list_db_name])
  exit -1
end

if options[:gen_params]
  # Generates a sample params file in current directory
  Params.generate_sample_params
  exit -1
end

# Setting RAM usage

if options[:max_ram] == nil
 
  raw_output=%x(free -g)
  splitted_output=raw_output.split("\n")
  splitted_output1=splitted_output[1].split(" ")
  free_ram = (splitted_output1[3].to_i * 0.85 - 0.5).round

  if free_ram.to_i > 1

    max_ram = [free_ram,"G"].join("")

    options[:max_ram] = max_ram

  else

    options[:max_ram] = '4G'

  end

end

#set logger
#system('rm logs/*')

FileUtils.mkdir('logs') if !File.exists?('logs')

$LOG = Logger.new(options[:logfile])
$LOG.datetime_format = "%Y-%m-%d %H:%M:%S"
#logger.level = Logger::INFO

#DEBUG < INFO < WARN < ERROR < FATAL < UNKNOWN

$LOG.info("SeqTrimBB version #{Seqtrimbb::SEQTRIM_VERSION}")
$LOG.info("Command: #{$0}")
$LOG.info(ROOT_PATH)

$LOG.info("Using options: \n"+ JSON::pretty_generate(options))

# Install/Check databases on DB_PATH

if options[:install_db] && File.writable?($DB_PATH)

  #install databases

  InstallDatabase.new(options[:install_db],$DB_PATH)

  # make bbsplit index
  
  CheckDatabase.new($DB_PATH,options[:workers],options[:max_ram])

  exit

else

  $LOG.info("Databases path: #{$DB_PATH} is not writable. Skipping Installing Databases step")
end

if options[:check_db] && File.writable?($DB_PATH)

  # checks for old bbsplit indexes and update them
  
  CheckDatabase.new($DB_PATH,options[:workers],options[:max_ram])

else

  $LOG.info("Databases path: #{$DB_PATH} is not writable. Skipping Checking Databases step")

end

# checks for essential arguments

required_options = options[:file] && options[:template]

if (ARGV.count != 0) || (!required_options) 
  puts "You must provide all required options"
  puts ""
  puts optparse.help
  exit(-1)
end

if File.exists?(options[:final_output_path])
  $LOG.error "Output folder #{options[:final_output_path]} already exists.\n Remove it if you want to launch SeqtrimBB again."
  exit(-1)
end

# check for template's existence

if (!File.exists?(options[:template]))
  if File.exists?(File.join(ROOT_PATH,'templates',options[:template]))
    options[:template] = File.join(ROOT_PATH,'templates',options[:template])
  else
    $LOG.error "Params file: #{options[:template]} doesn't exists. \n\nYou can use your own template or specify one from this list:\n============================="
    puts Dir.glob(File.join(ROOT_PATH,'templates','*.txt')).map{|t| File.basename(t)}
    exit(-1)
  end
end

$LOG.info "Using params file: #{options[:template]}"

# check file's existence and automatic format detection
 
if options[:file]

  nfiles = options[:file].count 

  $SAMPLEFILES = []

  options[:file].each do |seq_file|

    # file
    if (!seq_file.nil? && seq_file!='-' && !File.exists?(File.expand_path(seq_file)))
      $LOG.error "Input file: #{seq_file} doesn't exists"
      exit(-1)
    end

    file_to_test = File.expand_path(seq_file)

    $SAMPLEFILES << file_to_test

    # automatic format detection
    format_info = %x[testformat.sh #{file_to_test}].chop.split("\t")

    if (nfiles != 1)
     format_info[3] = "paired"
    end

    options[:qual_format] = format_info[0]
    options[:file_format] = format_info[1]
    options[:sample_type] = format_info[3]
    
  end	

  #preloading params 

  output = File.expand_path(DEFAULT_FINAL_OUTPUT_PATH)

  if options[:sample_type] == 'paired'

       file_one = File.join(output,'paired_1.fastq')
       file_two = File.join(output,'paired_2.fastq')

       $OUTPUTFILES = ['paired_1.fastq','paired_2.fastq']
       $OUTPUTFILES = ['paired_1.fastq.gz','paired_2.fastq.gz'] if options[:write_in_gzip]

    elsif options[:sample_type] == 'interleaved'

       file_one = File.join(output,'interleaved.fastq')

       $OUTPUTFILES = ['interleaved.fastq']
       $OUTPUTFILES = ['interleaved.fastq.gz'] if options[:write_in_gzip]

    else
    
       file_one = File.join(output,'sequences_.fastq')

       $OUTPUTFILES = ['sequences_.fastq']
       $OUTPUTFILES = ['sequences_.fastq.gz'] if options[:write_in_gzip]

    end
  
end

# qual file
if options[:qual]

  options[:qual].each do |qual_file|
    # qual file
    if (!qual_file.nil? && qual_file!='-' && !File.exists?(File.expand_path(qual_file)))
      $LOG.error "Input file: #{qual_file} doesn't exists"
      exit(-1)
    end
  end
  $SAMPLEQUALS = options[:qual]

end

s = Seqtrim.new(options)

#generate report

if !options[:skip_report] && system("which generate_report.rb > /dev/null ")
  cmd="generate_report.rb #{OUTPUT_PATH} 2> report_generation_errors.log"
  $LOG.info "Generating report #{cmd}"
  # `#{cmd}`
else
  skip_text=','
  if options[:skip_report]
    skip_text=' and remove the -R option from the command line.'
  end

  #$LOG.info "If you want a detailed report in PDF format, be sure you have installed the optional seqtrimbb_report gem (gem install seqtrimbb_report)#{skip_text}"
  $LOG.info "Closing"
end

if (Seqtrim.exit_status>=0) 
  FileUtils.mv OUTPUT_PATH, options[:final_output_path]
end

exit(Seqtrim.exit_status)
